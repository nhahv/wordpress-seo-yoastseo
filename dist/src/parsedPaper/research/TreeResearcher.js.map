{"version":3,"sources":["../../../../src/parsedPaper/research/TreeResearcher.js"],"names":["TreeResearcher","constructor","_researches","_data","addResearch","name","research","getResearches","hasResearch","getResearch","Error","doResearch","node","metadata","bustCache","researchResult","Promise","resolve","isLeafNode","hasResearchResult","setResearchResult","calculateFor","getResearchResult","children","resultsForChildren","all","map","child","mergeChildrenResults","addResearchData","researchName","data","getData"],"mappings":";;;;;;AAAA;;AAEA;;;;;;;AAOA,MAAMA,cAAN,CAAqB;AACpB;;;AAGAC,eAAc;AACb,OAAKC,WAAL,GAAmB,EAAnB;AACA,OAAKC,KAAL,GAAa,EAAb;AACA;;AAED;;;;;;;;;;;AAWAC,aAAaC,IAAb,EAAmBC,QAAnB,EAA8B;AAC7B,OAAKJ,WAAL,CAAkBG,IAAlB,IAA2BC,QAA3B;AACA;;AAED;;;;;AAKAC,iBAAgB;AACf,SAAO,KAAKL,WAAZ;AACA;;AAED;;;;;;;AAOAM,aAAaH,IAAb,EAAoB;AACnB,SAAO,mBAAK,KAAKH,WAAV,EAAuBG,IAAvB,CAAP;AACA;;AAED;;;;;;;;;;AAUAI,aAAaJ,IAAb,EAAoB;AACnB,MAAK,KAAKG,WAAL,CAAkBH,IAAlB,CAAL,EAAgC;AAC/B,UAAO,KAAKH,WAAL,CAAkBG,IAAlB,CAAP;AACA;AACD,QAAM,IAAIK,KAAJ,CAAY,IAAGL,IAAK,4BAApB,CAAN;AACA;;AAED;;;;;;;;;;AAUA,OAAMM,UAAN,CAAkBN,IAAlB,EAAwBO,IAAxB,EAA8BC,QAA9B,EAAwCC,YAAY,KAApD,EAA4D;AAC3D,QAAMR,WAAW,KAAKG,WAAL,CAAkBJ,IAAlB,CAAjB;AACA,MAAIU,iBAAiBC,QAAQC,OAAR,EAArB;;AAEA,MAAKX,SAASY,UAAT,CAAqBN,IAArB,CAAL,EAAmC;AAClC;;;;AAIA,OAAK,CAAEA,KAAKO,iBAAL,CAAwBd,IAAxB,CAAF,IAAoCS,SAAzC,EAAqD;AACpDF,SAAKQ,iBAAL,CAAwBf,IAAxB,GAA8B,MAAMC,SAASe,YAAT,CAAuBT,IAAvB,EAA6BC,QAA7B,CAApC;AACA;AACDE,oBAAiBH,KAAKU,iBAAL,CAAwBjB,IAAxB,CAAjB;AACA,GATD,MASO;AACN,SAAMkB,WAAWX,KAAKW,QAAtB;;AAEA;AACA,OAAKA,QAAL,EAAgB;AACf,UAAMC,qBAAqB,MAAMR,QAAQS,GAAR,CAAaF,SAASG,GAAT,CAAgBC,KAAF,IAAa;AACxE,YAAO,KAAKhB,UAAL,CAAiBN,IAAjB,EAAuBsB,KAAvB,EAA8Bd,QAA9B,CAAP;AACA,KAF6C,CAAb,CAAjC;;AAIAE,qBAAiBT,SAASsB,oBAAT,CAA+BJ,kBAA/B,CAAjB;AACA;AACD;;AAED,SAAOT,cAAP;AACA;;AAED;;;;;;;;AAQAc,iBAAiBC,YAAjB,EAA+BC,IAA/B,EAAsC;AACrC,OAAK5B,KAAL,CAAY2B,YAAZ,IAA6BC,IAA7B;AACA;;AAED;;;;;;;AAOAC,SAASF,YAAT,EAAwB;AACvB,SAAO,mBAAK,KAAK3B,KAAV,EAAiB2B,YAAjB,EAA+B,KAA/B,CAAP;AACA;AAzHmB;;kBA4HN9B,c","file":"TreeResearcher.js","sourcesContent":["import { get, has } from \"lodash-es\";\n\n/**\n * This contains all possible, default researches\n * and logic to apply these researches to a formatted text,\n * represented as a tree structure.\n *\n * @memberOf module:parsedPaper/research\n */\nclass TreeResearcher {\n\t/**\n\t * Makes a new TreeResearcher.\n\t */\n\tconstructor() {\n\t\tthis._researches = {};\n\t\tthis._data = {};\n\t}\n\n\t/**\n\t * Adds or overwrites a research to the list of available researches.\n\t *\n\t * **Note**: When a research is already known under the given name,\n\t * the previous research with this name gets overwritten!\n\t *\n\t * @param {string} name       The ID to which to map the research to.\n\t * @param {Research} research The research to add.\n\t *\n\t * @returns {void}\n\t */\n\taddResearch( name, research ) {\n\t\tthis._researches[ name ] = research;\n\t}\n\n\t/**\n\t * Returns all available researches.\n\t *\n\t * @returns {Object} An object containing all available researches.\n\t */\n\tgetResearches() {\n\t\treturn this._researches;\n\t}\n\n\t/**\n\t * Returns whether a research is known under this name.\n\t *\n\t * @param {string} name The name to get the research from.\n\t *\n\t * @returns {boolean} If a research is known under this name.\n\t */\n\thasResearch( name ) {\n\t\treturn has( this._researches, name );\n\t}\n\n\t/**\n\t * Gets the research with the given name.\n\t * If a research is not known under this name, false is returned instead.\n\t *\n\t * @throws {Error} When a research is not known under the given name.\n\t *\n\t * @param {string} name The name of the research to get.\n\t *\n\t * @returns {Research} The research stored under the given name.\n\t */\n\tgetResearch( name ) {\n\t\tif ( this.hasResearch( name ) ) {\n\t\t\treturn this._researches[ name ];\n\t\t}\n\t\tthrow new Error( `'${name}' research does not exist.` );\n\t}\n\n\t/**\n\t * Applies the research with the given name to the node and its descendants.\n\t *\n\t * @param {string} name The name of the research to apply to the node.\n\t * @param {module:parsedPaper/structure.Node} node The node to compute the research of.\n\t * @param {module:parsedPaper/structure.StructuredNode} metadata The node that holds the paper metadata.\n\t * @param {boolean} [bustCache=false] If we should force the results, as cached on each node, to be recomputed.\n\t *\n\t * @returns {Promise<*>} A promising research result.\n\t */\n\tasync doResearch( name, node, metadata, bustCache = false ) {\n\t\tconst research = this.getResearch( name );\n\t\tlet researchResult = Promise.resolve();\n\n\t\tif ( research.isLeafNode( node ) ) {\n\t\t\t/*\n\t\t\t  Compute research results for this node, or use the cached results when available.\n\t\t\t  Always compute it when we need to bust the cache.\n\t\t\t */\n\t\t\tif ( ! node.hasResearchResult( name ) || bustCache ) {\n\t\t\t\tnode.setResearchResult( name, await research.calculateFor( node, metadata ) );\n\t\t\t}\n\t\t\tresearchResult = node.getResearchResult( name );\n\t\t} else {\n\t\t\tconst children = node.children;\n\n\t\t\t// Heading and paragraph nodes do not have children.\n\t\t\tif ( children ) {\n\t\t\t\tconst resultsForChildren = await Promise.all( children.map( ( child ) => {\n\t\t\t\t\treturn this.doResearch( name, child, metadata );\n\t\t\t\t} ) );\n\n\t\t\t\tresearchResult = research.mergeChildrenResults( resultsForChildren );\n\t\t\t}\n\t\t}\n\n\t\treturn researchResult;\n\t}\n\n\t/**\n\t * Add research data to the researcher by the research name.\n\t *\n\t * @param {string} researchName The identifier of the research.\n\t * @param {Object} data         The data object.\n\t *\n\t * @returns {void}.\n\t */\n\taddResearchData( researchName, data ) {\n\t\tthis._data[ researchName ] = data;\n\t}\n\n\t/**\n\t * Return the research data from a research data provider by research name.\n\t *\n\t * @param {string} researchName The identifier of the research.\n\t *\n\t * @returns {Object|boolean} The data provided by the provider, false if the data do not exist\n\t */\n\tgetData( researchName ) {\n\t\treturn get( this._data, researchName, false );\n\t}\n}\n\nexport default TreeResearcher;\n"]}