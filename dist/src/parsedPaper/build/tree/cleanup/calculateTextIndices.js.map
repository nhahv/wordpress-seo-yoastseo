{"version":3,"sources":["../../../../../../src/parsedPaper/build/tree/cleanup/calculateTextIndices.js"],"names":["elementsThatCanBeClosed","currentElement","openElements","filter","el","endTag","sourceCodeLocation","endOffset","startOffset","closeElements","elementsToClose","currentOffset","sort","a","b","forEach","elementToClose","textEndIndex","endTagLength","handleIgnoredContent","element","textStartIndex","end","start","startTag","computeCommentStartEndTextIndices","computeElementStartTextIndex","startTagLength","calculateTextIndices","node","textContainer","formatting","length","type","push","ignoredHtmlElements","includes"],"mappings":";;;;;;AAAA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;AAiBA,MAAMA,0BAA0B,SAA1BA,uBAA0B,CAAUC,cAAV,EAA0BC,YAA1B,EAAyC;AACxE,QAAOA,aAAaC,MAAb,CAAqBC,MAAM;AACjC,QAAMC,SAASD,GAAGE,kBAAH,CAAsBD,MAArC;AACA,SAAOA,OAAOE,SAAP,IAAoBN,eAAeK,kBAAf,CAAkCE,WAA7D;AACA,EAHM,CAAP;AAIA,CALD;;AAOA;;;;;;;;;;;;;;;AAeA,MAAMC,gBAAgB,SAAhBA,aAAgB,CAAUC,eAAV,EAA2BC,aAA3B,EAA2C;AAChE;AACAD,iBAAgBE,IAAhB,CAAsB,CAAEC,CAAF,EAAKC,CAAL,KAAYD,EAAEP,kBAAF,CAAqBD,MAArB,CAA4BE,SAA5B,GAAwCO,EAAER,kBAAF,CAAqBD,MAArB,CAA4BE,SAAtG;;AAEAG,iBAAgBK,OAAhB,CAAyBC,kBAAkB;AAC1C,QAAMX,SAASW,eAAeV,kBAAf,CAAkCD,MAAjD;AACA;AACAW,iBAAeC,YAAf,GAA8BZ,OAAOG,WAAP,GAAqBG,aAAnD;AACA;;;AAGA,QAAMO,eAAeb,OAAOE,SAAP,GAAmBF,OAAOG,WAA/C;AACAG,mBAAiBO,YAAjB;AACA,EATD;;AAWA,QAAOP,aAAP;AACA,CAhBD;;AAkBA;;;;;;;;;AASA,MAAMQ,uBAAuB,SAAvBA,oBAAuB,CAAUC,OAAV,EAAmBT,aAAnB,EAAmC;AAC/D;AACAS,SAAQH,YAAR,GAAuBG,QAAQC,cAA/B;;AAEA;AACA,OAAMC,MAAMF,QAAQd,kBAAR,CAA2BD,MAA3B,GAAoCe,QAAQd,kBAAR,CAA2BD,MAA3B,CAAkCG,WAAtE,GAAoFY,QAAQd,kBAAR,CAA2BC,SAA3H;AACA,OAAMgB,QAAQH,QAAQd,kBAAR,CAA2BkB,QAA3B,GAAsCJ,QAAQd,kBAAR,CAA2BkB,QAA3B,CAAoCjB,SAA1E,GAAsFa,QAAQd,kBAAR,CAA2BE,WAA/H;;AAEAG,kBAAiBW,MAAMC,KAAvB;;AAEA,QAAOZ,aAAP;AACA,CAXD;;AAcA;;;;;;;;;;;AAWA,MAAMc,oCAAoC,SAApCA,iCAAoC,CAAUL,OAAV,EAAmBT,aAAnB,EAAmC;AAC5ES,SAAQC,cAAR,GAAyBD,QAAQd,kBAAR,CAA2BE,WAA3B,GAAyCG,aAAlE;AACAS,SAAQH,YAAR,GAAuBG,QAAQC,cAA/B;;AAEA,QAAOD,QAAQd,kBAAR,CAA2BC,SAA3B,GAAuCa,QAAQd,kBAAR,CAA2BE,WAAzE;AACA,CALD;;AAOA;;;;;;;;;;;AAWA,MAAMkB,+BAA+B,SAA/BA,4BAA+B,CAAUN,OAAV,EAAmBT,aAAnB,EAAmC;AACvE,OAAMa,WAAWJ,QAAQd,kBAAR,CAA2BkB,QAA5C;;AAEA;AACA,OAAMG,iBAAiBH,SAASjB,SAAT,GAAqBiB,SAAShB,WAArD;;AAEAG,kBAAiBgB,cAAjB;;AAEA;AACAP,SAAQC,cAAR,GAAyBG,SAASjB,SAAT,GAAqBI,aAA9C;;AAEA;;;;AAIA,KAAK,CAAES,QAAQd,kBAAR,CAA2BD,MAAlC,EAA2C;AAC1Ce,UAAQH,YAAR,GAAuBG,QAAQC,cAA/B;AACA;;AAED,QAAOV,aAAP;AACA,CApBD;;AAsBA;;;;;;;;;AASA,MAAMiB,uBAAuB,SAAvBA,oBAAuB,CAAUC,IAAV,EAAiB;AAC7C,KAAK,CAAEA,KAAKC,aAAL,CAAmBC,UAArB,IAAmCF,KAAKC,aAAL,CAAmBC,UAAnB,CAA8BC,MAA9B,KAAyC,CAAjF,EAAqF;AACpF;AACA;;AAED,OAAM9B,eAAe,EAArB;;AAEA;;;;AAIA,KAAIS,gBAAgBkB,KAAKvB,kBAAL,CAAwBkB,QAAxB,GAAmCK,KAAKvB,kBAAL,CAAwBkB,QAAxB,CAAiCjB,SAApE,GAAgFsB,KAAKvB,kBAAL,CAAwBE,WAA5H;;AAEAqB,MAAKC,aAAL,CAAmBC,UAAnB,CAA8BhB,OAA9B,CAAuCK,WAAW;AACjD;AACA,QAAMV,kBAAkBV,wBAAyBoB,OAAzB,EAAkClB,YAAlC,CAAxB;AACAS,kBAAgBF,cAAeC,eAAf,EAAgCC,aAAhC,CAAhB;AACA,yBAAST,YAAT,EAAuBQ,eAAvB;;AAEA;AACA,MAAKU,QAAQa,IAAR,KAAiB,UAAtB,EAAmC;AAClCtB,oBAAiBc,kCAAmCL,OAAnC,EAA4CT,aAA5C,CAAjB;AACA;AACA;;AAEDA,kBAAgBe,6BAA8BN,OAA9B,EAAuCT,aAAvC,CAAhB;;AAEA;AACA,MAAMS,QAAQd,kBAAR,CAA2BD,MAAjC,EAA0C;AACzCH,gBAAagC,IAAb,CAAmBd,OAAnB;AACA;;AAED;;;;;AAKA,MAAKe,mCAAoBC,QAApB,CAA8BhB,QAAQa,IAAtC,CAAL,EAAoD;AACnDtB,mBAAgBQ,qBAAsBC,OAAtB,EAA+BT,aAA/B,CAAhB;AACA;AACD,EA3BD;AA4BA;AACAF,eAAeP,YAAf,EAA6BS,aAA7B;AACA,CA3CD;;kBA6CeiB,oB","file":"calculateTextIndices.js","sourcesContent":["import { pullAll } from \"lodash-es\";\n\nimport { ignoredHtmlElements } from \"../html/htmlConstants\";\n\n/**\n * Gathers all elements that can be closed given the position of the current element in the source code.\n *\n * Elements that can be closed are all elements that are opened before this element, but in which this element is\n * not nested.\n * E.g.\n * ```html\n * <strong>Hello</strong><em>World<b>!!!</b></em>`\n * ```\n * with `<b>!!!</b>` as the current element,\n * means that the `<strong>` needs to be closed, but `<em>` **not**.\n *\n * @param {module:parsedPaper/structure.FormattingElement} currentElement The current element.\n * @param {module:parsedPaper/structure.FormattingElement[]} openElements The elements that are currently open.\n *\n * @returns {module:parsedPaper/structure.FormattingElement[]} The elements that can be closed.\n */\nconst elementsThatCanBeClosed = function( currentElement, openElements ) {\n\treturn openElements.filter( el => {\n\t\tconst endTag = el.sourceCodeLocation.endTag;\n\t\treturn endTag.endOffset <= currentElement.sourceCodeLocation.startOffset;\n\t} );\n};\n\n/**\n * Closes the elements that can be closed given the position of the current element within the source code.\n *\n * This does two things:\n *  1. The closed element's text end index is calculated based on the current offset.\n *  2. The closed element's end tag lengths are counted towards the current offset, to make sure that the computed position\n * of the formatting elements are still correct.\n *\n * @param {module:parsedPaper/structure.FormattingElement[]} elementsToClose The list of open elements that need to be closed\n * @param {number} currentOffset                                      The current offset when parsing the formatting elements\n *\n * @returns {number} The updated current offset\n *\n * @private\n */\nconst closeElements = function( elementsToClose, currentOffset ) {\n\t// Sort, so we close all elements in the right order.\n\telementsToClose.sort( ( a, b ) => a.sourceCodeLocation.endTag.endOffset - b.sourceCodeLocation.endTag.endOffset );\n\n\telementsToClose.forEach( elementToClose => {\n\t\tconst endTag = elementToClose.sourceCodeLocation.endTag;\n\t\t// Set the end position as seen in the text.\n\t\telementToClose.textEndIndex = endTag.startOffset - currentOffset;\n\t\t/*\n\t\t  Add the end tag length of the to be closed element to the total offset.\n\t\t */\n\t\tconst endTagLength = endTag.endOffset - endTag.startOffset;\n\t\tcurrentOffset += endTagLength;\n\t} );\n\n\treturn currentOffset;\n};\n\n/**\n * Adds the content length of the given element (the part between the tags) to the current offset\n * and adds the content to the element as a parameter.\n *\n * @param {module:parsedPaper/structure.FormattingElement} element The element of which to add the content length.\n * @param {number} currentOffset                            The current offset to which to add the length to.\n *\n * @returns {number} The updated current offset\n */\nconst handleIgnoredContent = function( element, currentOffset ) {\n\t// Has 0 length in text, so end = start.\n\telement.textEndIndex = element.textStartIndex;\n\n\t// Update current offset.\n\tconst end = element.sourceCodeLocation.endTag ? element.sourceCodeLocation.endTag.startOffset : element.sourceCodeLocation.endOffset;\n\tconst start = element.sourceCodeLocation.startTag ? element.sourceCodeLocation.startTag.endOffset : element.sourceCodeLocation.startOffset;\n\n\tcurrentOffset += end - start;\n\n\treturn currentOffset;\n};\n\n\n/**\n * Sets the start and end text positions of a comment.\n *\n * @param {module:parsedPaper/structure.FormattingElement}\telement\t\t\tThe formatting element to assign start and end text positions to.\n * @param {int}\t\t\t\t\t\t\t\t\t\t\t\tcurrentOffset\tA sum of all characters in the source code that don't get rendered\n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(e.g., tags, comments).\n *\n * @returns {number} The length of the comment.\n *\n * @private\n */\nconst computeCommentStartEndTextIndices = function( element, currentOffset ) {\n\telement.textStartIndex = element.sourceCodeLocation.startOffset - currentOffset;\n\telement.textEndIndex = element.textStartIndex;\n\n\treturn element.sourceCodeLocation.endOffset - element.sourceCodeLocation.startOffset;\n};\n\n/**\n * Sets the start and end text positions of one formatting element.\n *\n * @param {module:parsedPaper/structure.FormattingElement}\telement\t\t\tThe formatting element to assign start and end text positions to.\n * @param {int}\t\t\t\t\t\t\t\t\t\t\t\tcurrentOffset\tA sum of all characters in the source code that don't get rendered\n * \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(e.g., tags, comments).\n *\n * @returns {int} The updated currentOffset.\n *\n * @private\n */\nconst computeElementStartTextIndex = function( element, currentOffset ) {\n\tconst startTag = element.sourceCodeLocation.startTag;\n\n\t// For example: \"<strong>\".length\n\tconst startTagLength = startTag.endOffset - startTag.startOffset;\n\n\tcurrentOffset += startTagLength;\n\n\t// Set start position of element in heading's / paragraph's text.\n\telement.textStartIndex = startTag.endOffset - currentOffset;\n\n\t/*\n\t  Elements that have no end tags (e.g., void element like <img/> or self-closing elements) can be closed immediately.\n\t  The text length of those elements will be automatically 0.\n\t */\n\tif ( ! element.sourceCodeLocation.endTag ) {\n\t\telement.textEndIndex = element.textStartIndex;\n\t}\n\n\treturn currentOffset;\n};\n\n/**\n * Sets the start and end position of the text in formatting elements of the given node.\n *\n * @param {module:parsedPaper/structure.LeafNode} node The node containing a TextContainer\n *\n * @returns {void}\n *\n * @private\n */\nconst calculateTextIndices = function( node ) {\n\tif ( ! node.textContainer.formatting || node.textContainer.formatting.length === 0 ) {\n\t\treturn;\n\t}\n\n\tconst openElements = [];\n\n\t/*\n\t  Keeps track of the current total size of the start and end tags (and the ignored content)\n\t  These should not be counted towards the start and end position of the elements in the text.\n\t */\n\tlet currentOffset = node.sourceCodeLocation.startTag ? node.sourceCodeLocation.startTag.endOffset : node.sourceCodeLocation.startOffset;\n\n\tnode.textContainer.formatting.forEach( element => {\n\t\t// Close elements that can be closed and remove them from the list of open elements.\n\t\tconst elementsToClose = elementsThatCanBeClosed( element, openElements );\n\t\tcurrentOffset = closeElements( elementsToClose, currentOffset );\n\t\tpullAll( openElements, elementsToClose );\n\n\t\t// Comments are self-closing formatting elements that are completely ignored in rendering.\n\t\tif ( element.type === \"#comment\" ) {\n\t\t\tcurrentOffset += computeCommentStartEndTextIndices( element, currentOffset );\n\t\t\treturn;\n\t\t}\n\n\t\tcurrentOffset = computeElementStartTextIndex( element, currentOffset );\n\n\t\t// If there is an endTag, the element should be closed in one of the next iterations of the loop.\n\t\tif (  element.sourceCodeLocation.endTag ) {\n\t\t\topenElements.push( element );\n\t\t}\n\n\t\t/*\n\t\t  If this element is an ignored element its contents are not in the text,\n\t\t  so its content should be added to the respective formatting element instead,\n\t\t  and the current offset should be updated.\n\t\t */\n\t\tif ( ignoredHtmlElements.includes( element.type ) ) {\n\t\t\tcurrentOffset = handleIgnoredContent( element, currentOffset );\n\t\t}\n\t} );\n\t// Close all remaining elements.\n\tcloseElements( openElements, currentOffset );\n};\n\nexport default calculateTextIndices;\n"]}