{"version":3,"sources":["../../../../../../src/parsedPaper/build/tree/html/HTMLTreeConverter.js"],"names":["HTMLTreeConverter","convert","parse5Tree","root","StructuredNode","_convert","parent","ignoredHtmlElements","includes","nodeName","childNodes","node","child","_createChild","addChild","parse5Node","parentNode","nodeType","formatting","FormattingElement","sourceCodeLocation","_parseAttributes","attrs","_addLeafNodeContent","_addFormatting","Paragraph","headings","Heading","parseInt","ListItem","List","value","_addText","formattingElements","contentToAdd","add","location","LeafNode","previousChild","_previousChild","leafNodeAncestor","_leafNodeAncestor","isImplicit","exec","text","appendText","addFormatting","parse5attributes","length","reduce","attributes","attribute","name","children","element"],"mappings":"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","file":"HTMLTreeConverter.js","sourcesContent":["import { FormattingElement, Heading, Paragraph, StructuredNode, List, ListItem } from \"../../../structure/tree\";\nimport LeafNode from \"../../../structure/tree/nodes/LeafNode\";\nimport { formattingElements, headings, ignoredHtmlElements } from \"./htmlConstants\";\n\n/**\n * Converts a parse5 tree to a tree that can be analyzed.\n */\nclass HTMLTreeConverter {\n\t/**\n\t * Converts the parse5 tree to a Yoast tree.\n\t *\n\t * @param {Object} parse5Tree The parse5 tree to convert.\n\t *\n\t * @returns {module:parsedPaper/structure.Node} The converted tree.\n\t */\n\tconvert( parse5Tree ) {\n\t\tconst root = new StructuredNode( \"root\", null );\n\t\tthis._convert( parse5Tree, root );\n\t\treturn root;\n\t}\n\n\t/**\n\t * Converts the tree from a parse5 implementation to a Yoast tree.\n\t *\n\t * @param {Object}                                parse5Tree    The parse5 tree to convert.\n\t * @param {module:parsedPaper/structure.Node}     parent        The tree in progress.\n\t *\n\t * @returns {void}\n\t *\n\t * @private\n\t */\n\t_convert( parse5Tree, parent ) {\n\t\tif ( ignoredHtmlElements.includes( parse5Tree.nodeName ) ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( parse5Tree.childNodes ) {\n\t\t\tfor ( const node of parse5Tree.childNodes ) {\n\t\t\t\tconst child = this._createChild( node, parent );\n\n\t\t\t\tif ( child ) {\n\t\t\t\t\tparent.addChild( child );\n\t\t\t\t\tthis._convert( node, child );\n\t\t\t\t} else {\n\t\t\t\t\tthis._convert( node, parent );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates a new node for in the structured tree from the given parse 5 node.\n\t * Returns `null` if no node should be added to the tree.\n\t *\n\t * @param {Object}                            parse5Node The parse5 node that should be parsed.\n\t * @param {module:parsedPaper/structure.Node} parentNode The parent node.\n\t *\n\t * @returns {module:parsedPaper/structure.Node|null} The node that should be added to the tree, or `null` if no node should be added.\n\t *\n\t * @private\n\t */\n\t_createChild( parse5Node, parentNode ) {\n\t\tlet child = null;\n\n\t\tconst nodeType = parse5Node.nodeName;\n\n\t\tif ( ignoredHtmlElements.includes( nodeType ) ) {\n\t\t\tconst formatting = new FormattingElement( nodeType, parse5Node.sourceCodeLocation, this._parseAttributes( parse5Node.attrs ) );\n\t\t\tthis._addLeafNodeContent( formatting, this._addFormatting, parentNode, parse5Node.sourceCodeLocation );\n\t\t} else if ( nodeType === \"p\" ) {\n\t\t\t// Paragraph.\n\t\t\tchild = new Paragraph( parse5Node.sourceCodeLocation );\n\t\t} else if ( headings.includes( nodeType ) ) {\n\t\t\t// Heading.\n\t\t\tchild = new Heading( parseInt( nodeType[ 1 ], 10 ), parse5Node.sourceCodeLocation );\n\t\t} else if ( nodeType === \"li\" ) {\n\t\t\t// List item.\n\t\t\tchild = new ListItem( parse5Node.sourceCodeLocation );\n\t\t} else if ( nodeType === \"ol\" || nodeType === \"ul\" ) {\n\t\t\t// List node.\n\t\t\tchild = new List( nodeType === \"ol\", parse5Node.sourceCodeLocation );\n\t\t} else if ( nodeType === \"#text\" ) {\n\t\t\t// Text (outside of an ignored element).\n\t\t\tchild = this._addLeafNodeContent( parse5Node.value, this._addText, parentNode, parse5Node.sourceCodeLocation );\n\t\t} else if ( formattingElements.includes( nodeType ) ) {\n\t\t\t// Formatting element.\n\t\t\tconst formatting = new FormattingElement( nodeType, parse5Node.sourceCodeLocation, this._parseAttributes( parse5Node.attrs ) );\n\t\t\tchild = this._addLeafNodeContent( formatting, this._addFormatting, parentNode, parse5Node.sourceCodeLocation );\n\t\t} else {\n\t\t\t// Other element (`div`, `section`, `article`, etc.).\n\t\t\tchild = new StructuredNode( nodeType, parse5Node.sourceCodeLocation );\n\t\t}\n\n\t\treturn child;\n\t}\n\n\t/**\n\t * Adds leaf node content (text or formatting) to the tree according to a predefined strategy:\n\t *\n\t * If the content has a leaf node (paragraph, heading, list item) parent or ancestor: add it to this leaf node.\n\t * Else: wrap the content in an implicit paragraph, and add the content to it in such a way that runs\n\t * of phrasing content make up one implicit paragraph.\n\t *\n\t * @param {string|module:parsedPaper/structure.FormattingElement} contentToAdd The content to add.\n\t * @param {function}                                              add          A function that adds the content to the specified leaf node.\n\t * @param {module:parsedPaper/structure.Node}                     parent       The parent to which to try to add the content.\n\t * @param {Object}                                                location     The location of the content as parsed by parse5.\n\t *\n\t * @returns {null|module:parsedPaper/structure.Paragraph|null} The implicit paragraph, if one was created.\n\t *\n\t * @private\n\t */\n\t_addLeafNodeContent( contentToAdd, add, parent, location ) {\n\t\tif ( parent instanceof LeafNode ) {\n\t\t\tadd( parent, contentToAdd );\n\t\t\treturn null;\n\t\t}\n\n\t\tconst previousChild = this._previousChild( parent );\n\t\tconst leafNodeAncestor = this._leafNodeAncestor( parent );\n\n\t\tif ( leafNodeAncestor instanceof Paragraph ) {\n\t\t\tadd( leafNodeAncestor, contentToAdd );\n\t\t\treturn null;\n\t\t} else if ( previousChild && previousChild instanceof Paragraph && previousChild.isImplicit ) {\n\t\t\tadd( previousChild, contentToAdd );\n\t\t\treturn null;\n\t\t}\n\n\t\t// Don't create an implicit paragraph when the content is whitespace only.\n\t\tif ( /^\\s*$/.exec( contentToAdd ) ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst child = new Paragraph( location, true );\n\t\tadd( child, contentToAdd );\n\t\treturn child;\n\t}\n\n\t/**\n\t * Add text to the parent leaf node.\n\t *\n\t * @param {module:parsedPaper/structure.LeafNode} parent The leaf node to which to add the text.\n\t * @param {string}                                text   The text to add to the node.\n\t *\n\t * @returns {void}\n\t *\n\t * @private\n\t */\n\t_addText( parent, text ) {\n\t\tparent.appendText( text );\n\t}\n\n\t/**\n\t * Add a formatting element to the parent leaf node.\n\t *\n\t * @param {module:parsedPaper/structure.LeafNode}          parent     The leaf node to which to add the formatting.\n\t * @param {module:parsedPaper/structure.FormattingElement} formatting The formatting element to add.\n\t *\n\t * @returns {void}\n\t *\n\t * @private\n\t */\n\t_addFormatting( parent, formatting ) {\n\t\tparent.addFormatting( formatting );\n\t}\n\n\t/**\n\t * Parses the HTML element attributes from parse5's format to a plain JS object.\n\t *\n\t * @example\n\t *\n\t * const attributes = _parseAttributes( { name: \"id\", value: \"an-id\" } ) // becomes { id: \"an-id\" }.\n\t *\n\t * @param {Array<{ name: string, value: string }>} parse5attributes The attributes as parsed by parse5.\n\t *\n\t * @returns {Object} The parsed attributes.\n\t *\n\t * @private\n\t */\n\t_parseAttributes( parse5attributes ) {\n\t\tif ( parse5attributes && parse5attributes.length > 0 ) {\n\t\t\treturn parse5attributes.reduce( ( attributes, attribute ) => {\n\t\t\t\tattributes[ attribute.name ] = attribute.value;\n\t\t\t\treturn attributes;\n\t\t\t}, {} );\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the last child of the given parent.\n\t *\n\t * @param {module:parsedPaper/structure.StructuredNode} parent The parent.\n\t *\n\t * @returns {module:parsedPaper/structure.Node} The parent's last child.\n\t *\n\t * @private\n\t */\n\t_previousChild( parent ) {\n\t\tif ( parent.children ) {\n\t\t\treturn parent.children[ parent.children.length - 1 ];\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Try to find the leaf node ancestor of this node. Returns `null` if the node does not have one.\n\t *\n\t * @param {module:parsedPaper/structure.Node} element The node for which to find the leaf node ancestor.\n\t *\n\t * @returns {null|module:parsedPaper/structure.Node} The leaf node ancestor, if it has one, `null` if not.\n\t *\n\t * @private\n\t */\n\t_leafNodeAncestor( element ) {\n\t\tconst parent = element.parent;\n\n\t\tif ( ! parent ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( element instanceof LeafNode ) {\n\t\t\treturn parent;\n\t\t}\n\n\t\treturn this._leafNodeAncestor( parent );\n\t}\n}\n\nexport default HTMLTreeConverter;\n"]}