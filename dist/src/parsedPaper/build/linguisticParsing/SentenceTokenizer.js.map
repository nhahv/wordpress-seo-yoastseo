{"version":3,"sources":["../../../../../src/parsedPaper/build/linguisticParsing/SentenceTokenizer.js"],"names":["fullStop","sentenceDelimiters","fullStopRegex","RegExp","sentenceDelimiterRegex","sentenceRegex","blockStartRegex","blockEndRegex","whiteSpaceStartRegex","whiteSpaceEndRegex","SentenceTokenizer","isNumber","character","parseInt","isQuotation","isPunctuation","removeDuplicateWhitespace","text","replace","isCapitalLetter","toLocaleLowerCase","getNextTwoCharacters","nextTokens","next","src","isValidSentenceBeginning","sentenceBeginning","isSentenceStart","token","type","createTokenizer","tokens","tokenizer","push","addRule","tokenize","onText","end","e","console","error","tokenizer2","determineIndices","sentences","currentIndex","sentence","startIndex","setStartIndex","endIndex","length","setEndIndex","trimWhiteSpaceAtStart","whiteSpaceLength","match","setText","getText","slice","getStartIndex","trimWhiteSpaceAtEnd","getEndIndex","trimWhiteSpaces","getSentencesFromTokens","tokenArray","tokenSentences","currentSentence","Sentence","nextSentenceStart","forEach","i","hasNextSentence","nextCharacters","nextToken","secondToNextToken","appendText"],"mappings":"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","file":"SentenceTokenizer.js","sourcesContent":["import { isUndefined } from \"lodash-es\";\nimport { isNaN } from \"lodash-es\";\n\nimport core from \"tokenizer2/core\";\n\nimport { normalize as normalizeQuotes } from \"../../../stringProcessing/quotes.js\";\nimport Sentence from \"./Sentence\";\n\n// All characters that indicate a sentence delimiter.\nconst fullStop = \".\";\n// The \\u2026 character is an ellipsis\nconst sentenceDelimiters = \"?!;\\u2026\";\n\nconst fullStopRegex = new RegExp( \"^[\" + fullStop + \"]$\" );\nconst sentenceDelimiterRegex = new RegExp( \"^[\" + sentenceDelimiters + \"]$\" );\nconst sentenceRegex = new RegExp( \"^[^\" + fullStop + sentenceDelimiters + \"\\\\(\\\\)\\\\[\\\\]]+$\" );\n\nconst blockStartRegex = /^\\s*[[({]\\s*$/;\nconst blockEndRegex = /^\\s*[\\])}]\\s*$/;\n\nconst whiteSpaceStartRegex = /^\\s*/;\nconst whiteSpaceEndRegex = /\\s*$/;\n\n/**\n * Class for tokenizing a (html) text into sentences.\n */\nexport default class SentenceTokenizer {\n\t/**\n\t * Returns whether or not a certain character is a number.\n\t *\n\t * @param {string} character The character to check.\n\t * @returns {boolean} Whether or not the character is a capital letter.\n\t */\n\tisNumber( character ) {\n\t\treturn ! isNaN( parseInt( character, 10 ) );\n\t}\n\n\t/**\n\t * Returns whether or not a given character is quotation mark.\n\t *\n\t * @param {string} character The character to check.\n\t *\n\t * @returns {boolean} Whether or not the given character is a quotation mark.\n\t */\n\tisQuotation( character ) {\n\t\tcharacter = normalizeQuotes( character );\n\n\t\treturn \"'\" === character ||\n\t\t\t\"\\\"\" === character;\n\t}\n\n\t/**\n\t * Returns whether or not a given character is a punctuation mark that can be at the beginning\n\t * of a sentence, like ¿ and ¡ used in Spanish.\n\t *\n\t * @param {string} character The character to check.\n\t *\n\t * @returns {boolean} Whether or not the given character is a punctuation mark.\n\t */\n\tisPunctuation( character ) {\n\t\treturn \"¿\" === character ||\n\t\t\t\"¡\" === character;\n\t}\n\n\t/**\n\t * Removes duplicate whitespace from a given text.\n\t *\n\t * @param {string} text The text with duplicate whitespace.\n\t * @returns {string} The text without duplicate whitespace.\n\t */\n\tremoveDuplicateWhitespace( text ) {\n\t\treturn text.replace( /\\s+/, \" \" );\n\t}\n\n\t/**\n\t * Returns whether or not a certain character is a capital letter.\n\t *\n\t * @param {string} character The character to check.\n\t *\n\t * @returns {boolean} Whether or not the character is a capital letter.\n\t */\n\tisCapitalLetter( character ) {\n\t\treturn character !== character.toLocaleLowerCase();\n\t}\n\n\t/**\n\t * Retrieves the next two characters from an array with the two next tokens.\n\t *\n\t * @param {Array} nextTokens The two next tokens. Might be undefined.\n\t *\n\t * @returns {string} The next two characters.\n\t */\n\tgetNextTwoCharacters( nextTokens ) {\n\t\tlet next = \"\";\n\n\t\tif ( ! isUndefined( nextTokens[ 0 ] ) ) {\n\t\t\tnext += nextTokens[ 0 ].src;\n\t\t}\n\n\t\tif ( ! isUndefined( nextTokens[ 1 ] ) ) {\n\t\t\tnext += nextTokens[ 1 ].src;\n\t\t}\n\n\t\tnext = this.removeDuplicateWhitespace( next );\n\n\t\treturn next;\n\t}\n\n\t/**\n\t * Checks if the sentenceBeginning beginning is a valid beginning.\n\t *\n\t * @param {string} sentenceBeginning The beginning of the sentence to validate.\n\t *\n\t * @returns {boolean} Returns true if it is a valid beginning, false if it is not.\n\t */\n\tisValidSentenceBeginning( sentenceBeginning ) {\n\t\treturn (\n\t\t\tthis.isCapitalLetter( sentenceBeginning ) ||\n\t\t\tthis.isNumber( sentenceBeginning ) ||\n\t\t\tthis.isQuotation( sentenceBeginning ) ||\n\t\t\tthis.isPunctuation( sentenceBeginning )\n\t\t);\n\t}\n\n\t/**\n\t * Checks if the token is a valid sentence ending.\n\t *\n\t * @param {Object} token The token to validate.\n\t *\n\t * @returns {boolean} Returns true if the token is valid ending, false if it is not.\n\t */\n\tisSentenceStart( token ) {\n\t\treturn ( ! isUndefined( token ) && (\n\t\t\t\"html-start\" === token.type ||\n\t\t\t\"html-end\" === token.type ||\n\t\t\t\"block-start\" === token.type\n\t\t) );\n\t}\n\n\t/**\n\t * Creates a tokenizer.\n\t *\n\t * @returns {Object} The tokenizer and the tokens.\n\t */\n\tcreateTokenizer() {\n\t\tconst tokens = [];\n\t\tconst tokenizer = core( function( token ) {\n\t\t\ttokens.push( token );\n\t\t} );\n\n\t\ttokenizer.addRule( fullStopRegex, \"full-stop\" );\n\t\ttokenizer.addRule( blockStartRegex, \"block-start\" );\n\t\ttokenizer.addRule( blockEndRegex, \"block-end\" );\n\t\ttokenizer.addRule( sentenceDelimiterRegex, \"sentence-delimiter\" );\n\t\ttokenizer.addRule( sentenceRegex, \"sentence\" );\n\n\t\treturn {\n\t\t\ttokenizer,\n\t\t\ttokens,\n\t\t};\n\t}\n\n\t/**\n\t * Tokenizes the given text using the given tokenizer.\n\t *\n\t * @param {Tokenizer} tokenizer The tokenizer to use.\n\t * @param {string}    text      The text to tokenize.\n\t *\n\t * @returns {void}\n\t */\n\ttokenize( tokenizer, text ) {\n\t\ttokenizer.onText( text );\n\n\t\ttry {\n\t\t\ttokenizer.end();\n\t\t} catch ( e ) {\n\t\t\tconsole.error( \"Tokenizer end error:\", e, e.tokenizer2 );\n\t\t}\n\t}\n\n\t/**\n\t * Determines the start and end indices of a set of sentences form a text.\n\t *\n\t * @param {Sentence[]} sentences A set of sentences for which to determine indices.\n\t *\n\t * @returns {void}\n\t */\n\tdetermineIndices( sentences ) {\n\t\tlet currentIndex = 0;\n\n\t\tfor ( const sentence of sentences ) {\n\t\t\tconst startIndex = currentIndex;\n\t\t\tsentence.setStartIndex( currentIndex );\n\t\t\tconst endIndex = startIndex + sentence.text.length - 1;\n\t\t\tsentence.setEndIndex( endIndex );\n\t\t\tcurrentIndex = endIndex + 1;\n\t\t}\n\t}\n\n\t/**\n\t * Trims the white space from the beginning of a sentence and adjusts the sentence start index accordingly.\n\t *\n\t * @param {Sentence} sentence The sentence for which to trim the white space at the start.\n\t *\n\t * @returns {void}\n\t */\n\ttrimWhiteSpaceAtStart( sentence ) {\n\t\tconst whiteSpaceLength = sentence.text.match( whiteSpaceStartRegex )[ 0 ].length;\n\t\tsentence.setText( sentence.getText().slice( whiteSpaceLength ) );\n\t\tsentence.setStartIndex( sentence.getStartIndex() + whiteSpaceLength  );\n\t}\n\n\t/**\n\t * Trims the white space from the end of a sentence and adjusts the sentence end index accordingly.\n\t *\n\t * @param {Sentence} sentence The sentence for which to trim the white space at the end.\n\t *\n\t * @returns {void}\n\t */\n\ttrimWhiteSpaceAtEnd( sentence ) {\n\t\tconst whiteSpaceLength = sentence.text.match( whiteSpaceEndRegex )[ 0 ].length;\n\t\tsentence.setText( sentence.getText().slice( 0, sentence.getText().length - whiteSpaceLength ) );\n\t\tsentence.setEndIndex( sentence.getEndIndex() - whiteSpaceLength );\n\t}\n\n\t/**\n\t * Trims white space from the beginning and end of sentences and adjusts the indices\n\t * of the sentence beginnings and ends accordingly.\n\t *\n\t * @param {Sentence[]} sentences The sentences for which to trim the whitespace.\n\t *\n\t * @returns {void}\n\t */\n\ttrimWhiteSpaces( sentences ) {\n\t\tfor ( const sentence of sentences ) {\n\t\t\tthis.trimWhiteSpaceAtStart( sentence );\n\t\t\tthis.trimWhiteSpaceAtEnd( sentence );\n\t\t}\n\t}\n\n\t/**\n\t * Returns an array of sentence objects for a given array of tokens; assumes that the text has already been split into blocks.\n\t *\n\t * @param {Object[]} tokenArray The tokens from the sentence tokenizer.\n\t *\n\t * @returns {Sentence[]} An array of sentence objects.\n\t */\n\tgetSentencesFromTokens( tokenArray ) {\n\t\tconst tokenSentences = [];\n\t\tlet currentSentence = new Sentence( \"\", 0, 0 ),\n\t\t\tnextSentenceStart;\n\n\t\ttokenArray.forEach( ( token, i ) => {\n\t\t\tlet hasNextSentence, nextCharacters;\n\t\t\tconst nextToken = tokenArray[ i + 1 ];\n\t\t\tconst secondToNextToken = tokenArray[ i + 2 ];\n\n\t\t\tswitch ( token.type ) {\n\t\t\t\tcase \"sentence\":\n\t\t\t\t\tcurrentSentence.appendText( token.src );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"sentence-delimiter\":\n\t\t\t\t\tcurrentSentence.appendText( token.src );\n\t\t\t\t\tif ( ! isUndefined( nextToken ) && \"block-end\" !== nextToken.type && \"sentence-delimiter\" !== nextToken.type ) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = new Sentence( \"\" );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"full-stop\":\n\t\t\t\t\tcurrentSentence.appendText( token.src );\n\n\t\t\t\t\tnextCharacters = this.getNextTwoCharacters( [ nextToken, secondToNextToken ] );\n\n\t\t\t\t\t// For a new sentence we need to check the next two characters.\n\t\t\t\t\thasNextSentence = nextCharacters.length >= 2;\n\t\t\t\t\tnextSentenceStart = hasNextSentence ? nextCharacters[ 1 ] : \"\";\n\t\t\t\t\t// If the next character is a number, never split. For example: IPv4-numbers.\n\t\t\t\t\tif ( hasNextSentence && this.isNumber( nextCharacters[ 0 ] ) ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// Only split on sentence delimiters when the next sentence looks like the start of a sentence.\n\t\t\t\t\tif ( ( hasNextSentence && this.isValidSentenceBeginning( nextSentenceStart ) ) || this.isSentenceStart( nextToken ) ) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = new Sentence( \"\" );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"block-start\":\n\t\t\t\t\tcurrentSentence.appendText( token.src );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"block-end\":\n\t\t\t\t\tcurrentSentence.appendText( token.src );\n\t\t\t\t\tnextCharacters = this.getNextTwoCharacters( [ nextToken, secondToNextToken ] );\n\n\t\t\t\t\t// For a new sentence we need to check the next two characters.\n\t\t\t\t\thasNextSentence = nextCharacters.length >= 2;\n\t\t\t\t\tnextSentenceStart = hasNextSentence ? nextCharacters[ 0 ] : \"\";\n\t\t\t\t\t// If the next character is a number, never split. For example: IPv4-numbers.\n\t\t\t\t\tif ( hasNextSentence && this.isNumber( nextCharacters[ 0 ] ) ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ( hasNextSentence && this.isValidSentenceBeginning( nextSentenceStart ) ) || this.isSentenceStart( nextToken ) ) {\n\t\t\t\t\t\ttokenSentences.push( currentSentence );\n\t\t\t\t\t\tcurrentSentence = new Sentence( \"\" );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} );\n\n\t\tif ( currentSentence.getText()  !== \"\"  ) {\n\t\t\ttokenSentences.push( currentSentence );\n\t\t}\n\n\t\tthis.determineIndices( tokenSentences );\n\n\t\tthis.trimWhiteSpaces( tokenSentences );\n\n\t\treturn tokenSentences;\n\t}\n}\n"]}