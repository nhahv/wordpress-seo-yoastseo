{"version":3,"sources":["../../../../../../src/parsedPaper/structure/tree/nodes/Node.js"],"names":["Node","constructor","type","sourceCodeLocation","SourceCodeLocation","parent","_researchResult","setResearchResult","researchName","researchResult","getResearchResult","hasResearchResult","map","mapFunction","node","children","length","child","forEach","fun","_removeParent","key","value","toString","indentation","JSON","stringify"],"mappings":";;;;;;AAAA;;AACA;;;;;;AAEA;;;;;;AAMA,MAAMA,IAAN,CAAW;AACV;;;;;;;;AAQAC,aAAaC,IAAb,EAAmBC,kBAAnB,EAAwC;AACvC;;;;AAIA,OAAKD,IAAL,GAAYA,IAAZ;;AAEA,MAAKC,kBAAL,EAA0B;AACzB;;;;AAIA,QAAKA,kBAAL,GAA0B,IAAIC,4BAAJ,CAAwBD,kBAAxB,CAA1B;AACA;;AAED;;;;AAIA,OAAKE,MAAL,GAAc,IAAd;;AAEA;;;;;AAKA,OAAKC,eAAL,GAAuB,EAAvB;AACA;;AAED;;;;;;;;AAQAC,mBAAmBC,YAAnB,EAAiCC,cAAjC,EAAkD;AACjD,OAAKH,eAAL,CAAsBE,YAAtB,IAAuCC,cAAvC;AACA;;AAED;;;;;;;AAOAC,mBAAmBF,YAAnB,EAAkC;AACjC,SAAO,mBAAK,KAAKF,eAAV,EAA2BE,YAA3B,EAAyC,IAAzC,CAAP;AACA;;AAED;;;;;;;AAOAG,mBAAmBH,YAAnB,EAAkC;AACjC,SAAO,mBAAK,KAAKF,eAAV,EAA2BE,YAA3B,CAAP;AACA;;AAED;;;;;;;AAOAI,KAAKC,WAAL,EAAmB;AAClB;AACA,QAAMC,OAAOD,YAAa,IAAb,CAAb;AACA,MAAKC,KAAKC,QAAL,IAAiBD,KAAKC,QAAL,CAAcC,MAAd,GAAuB,CAA7C,EAAiD;AAChD;AACAF,QAAKC,QAAL,GAAgBD,KAAKC,QAAL,CAAcH,GAAd,CAAmBK,SAASA,MAAML,GAAN,CAAWC,WAAX,CAA5B,CAAhB;AACA;AACD,SAAOC,IAAP;AACA;;AAED;;;;;;;;;;AAUA;;;;;;;AAOAI,SAASC,GAAT,EAAe;AACdA,MAAK,IAAL;AACA,MAAK,KAAKJ,QAAL,IAAiB,KAAKA,QAAL,CAAcC,MAAd,GAAuB,CAA7C,EAAiD;AAChD,QAAKD,QAAL,CAAcG,OAAd,CAAuBC,GAAvB;AACA;AACD;;AAED;;;;;;;;;;;AAWA,QAAOC,aAAP,CAAsBC,GAAtB,EAA2BC,KAA3B,EAAmC;AAClC,MAAKD,QAAQ,QAAb,EAAwB;AACvB;AACA;AACD,SAAOC,KAAP;AACA;;AAED;;;;;;;;AAQAC,UAAUC,cAAc,CAAxB,EAA4B;AAC3B,SAAOC,KAAKC,SAAL,CAAgB,IAAhB,EAAsB1B,KAAKoB,aAA3B,EAA0CI,WAA1C,CAAP;AACA;AA7IS;;kBAgJIxB,I","file":"Node.js","sourcesContent":["import { has, get } from \"lodash-es\";\nimport SourceCodeLocation from \"../SourceCodeLocation\";\n\n/**\n * Abstract class representing a node in the structured tree.\n * @abstract\n *\n * @memberOf module:parsedPaper/structure\n */\nclass Node {\n\t/**\n\t * Makes a new Node.\n\t *\n\t * @param {string} type               The type of Node (should be unique for each child class of Node).\n\t * @param {?Object} sourceCodeLocation The parse5 formatted location of the element inside of the source code.\n\t *\n\t * @abstract\n\t */\n\tconstructor( type, sourceCodeLocation ) {\n\t\t/**\n\t\t * Type of node (unique for each child class of Node).\n\t\t * @type {string}\n\t\t */\n\t\tthis.type = type;\n\n\t\tif ( sourceCodeLocation ) {\n\t\t\t/**\n\t\t\t * Location inside of the source code.\n\t\t\t * @type {SourceCodeLocation}\n\t\t\t */\n\t\t\tthis.sourceCodeLocation = new SourceCodeLocation( sourceCodeLocation );\n\t\t}\n\n\t\t/**\n\t\t * The parent node of this node.\n\t\t * @type {module:parsedPaper/structure.Node|null}\n\t\t */\n\t\tthis.parent = null;\n\n\t\t/**\n\t\t * Cache for the research results.\n\t\t * @type {Object}\n\t\t * @private\n\t\t */\n\t\tthis._researchResult = {};\n\t}\n\n\t/**\n\t * Stores the research result on this node.\n\t *\n\t * @param {string} researchName   The name of the research of which to store the results.\n\t * @param {Object} researchResult The results to store.\n\t *\n\t * @returns {void}\n\t */\n\tsetResearchResult( researchName, researchResult ) {\n\t\tthis._researchResult[ researchName ] = researchResult;\n\t}\n\n\t/**\n\t * Returns the research result for the research with the given name.\n\t *\n\t * @param {string} researchName The name of the research of which to return the stored results.\n\t *\n\t * @returns {Object|null} The stored results, or null if not found.\n\t */\n\tgetResearchResult( researchName ) {\n\t\treturn get( this._researchResult, researchName, null );\n\t}\n\n\t/**\n\t * Checks whether results exist for the research with the given name.\n\t *\n\t * @param {string} researchName The name of the research to check.\n\t *\n\t * @returns {boolean} Whether results exists for the research with the given name.\n\t */\n\thasResearchResult( researchName ) {\n\t\treturn has( this._researchResult, researchName );\n\t}\n\n\t/**\n\t * Maps the given function to each Node in this tree.\n\t *\n\t * @param {module:parsedPaper/structure.Node.mapFunction} mapFunction The function that should be mapped to each Node in the tree.\n\t *\n\t * @returns {module:parsedPaper/structure.Node} A new tree, after the given function has been mapped on each Node.\n\t */\n\tmap( mapFunction ) {\n\t\t// Map function over contents of this node.\n\t\tconst node = mapFunction( this );\n\t\tif ( node.children && node.children.length > 0 ) {\n\t\t\t// Map function over node's children (if it has any).\n\t\t\tnode.children = node.children.map( child => child.map( mapFunction ) );\n\t\t}\n\t\treturn node;\n\t}\n\n\t/**\n\t * Callback function for the Node's map-function.\n\t *\n\t * @callback module:parsedPaper/structure.Node.mapFunction\n\t *\n\t * @param {module:parsedPaper/structure.Node} currentValue The current Node being processed.\n\t *\n\t * @returns {module:parsedPaper/structure.Node} The current Node after being processed by this function.\n\t */\n\n\t/**\n\t * Executes the given function on each node in this tree.\n\t *\n\t * @param{function} fun The function to apply to each node in the tree.\n\t *\n\t * @returns {void}\n\t */\n\tforEach( fun ) {\n\t\tfun( this );\n\t\tif ( this.children && this.children.length > 0 ) {\n\t\t\tthis.children.forEach( fun );\n\t\t}\n\t}\n\n\t/**\n\t * Custom replacer function for replacing 'parent' with nothing.\n\t * This is done to remove cycles from the tree.\n\t *\n\t * @param {string} key   The key.\n\t * @param {Object} value The value.\n\t *\n\t * @returns {Object} The (optionally replaced) value.\n\t *\n\t * @private\n\t */\n\tstatic _removeParent( key, value ) {\n\t\tif ( key === \"parent\" ) {\n\t\t\treturn;\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Transforms this tree to a string representation.\n\t * For use in e.g. logging to the console or to a text file.\n\t *\n\t * @param {number|string} [indentation = 2] The space with which to indent each successive level in the JSON tree.\n\t *\n\t * @returns {string} This tree, transformed to a string.\n\t */\n\ttoString( indentation = 2 ) {\n\t\treturn JSON.stringify( this, Node._removeParent, indentation );\n\t}\n}\n\nexport default Node;\n"]}