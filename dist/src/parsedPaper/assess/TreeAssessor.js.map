{"version":3,"sources":["../../../../src/parsedPaper/assess/TreeAssessor.js"],"names":["TreeAssessor","constructor","options","i18n","researcher","scoreAggregator","_assessments","assessments","forEach","assessment","setResearcher","getAssessments","assess","paper","node","applicableAssessments","getApplicableAssessments","results","Promise","all","map","applyAssessment","validResults","filter","result","getScore","score","aggregate","apply","catch","AssessmentResult","text","sprintf","dgettext","name","registerAssessment","push","removeAssessment","index","findIndex","deleted","splice","getAssessment","assessmentToReturn","find","setAssessments","promises","isApplicable","then","applicable"],"mappings":"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","file":"TreeAssessor.js","sourcesContent":["import AssessmentResult from \"../../values/AssessmentResult\";\n\n/**\n * Analyzes a paper by doing a list of assessments on a tree representation of a text and its metadata.\n * Aggregates the scores on each individual assessment into an overall score.\n *\n * This score can represent anything from the readability to the SEO of the given text and metadata.\n *\n * @memberOf module:parsedPaper/assess\n */\nclass TreeAssessor {\n\t/**\n\t * Creates a new assessor.\n\t *\n\t * @param {Object}                                     options                 Assessor options.\n\t * @param {Jed}                                        options.i18n            A Jed object to use for translations.\n\t * @param {module:parsedPaper/research.TreeResearcher} options.researcher      Supplies the assessments with researches and their\n\t *                                                                             (cached) results.\n\t * @param {module:parsedPaper/assess.ScoreAggregator}  options.scoreAggregator Aggregates the scores on the individual assessments into one.\n\t * @param {module:parsedPaper/assess.Assessment[]}     [options.assessments]   The list of assessments to apply.\n\t */\n\tconstructor( options ) {\n\t\t/**\n\t\t * A Jed object to use for translations.\n\t\t * @type {Jed}\n\t\t */\n\t\tthis.i18n = options.i18n;\n\t\t/**\n\t\t * Supplies the assessments with researches and their (cached) results.\n\t\t * @type {module:parsedPaper/research.TreeResearcher}\n\t\t */\n\t\tthis.researcher = options.researcher;\n\t\t/**\n\t\t * Aggregates the scores on the individual assessments into one overall score.\n\t\t * @type {module:parsedPaper/assess.ScoreAggregator}\n\t\t */\n\t\tthis.scoreAggregator = options.scoreAggregator;\n\t\t/**\n\t\t * The list of assessments to apply.\n\t\t * @type {module:parsedPaper/assess.Assessment[]}\n\t\t */\n\t\tthis._assessments = options.assessments || [];\n\t\t// Make sure that all of the assessments have the researcher.\n\t\tthis._assessments.forEach( assessment => assessment.setResearcher( this.researcher ) );\n\t}\n\n\t/**\n\t * Returns the list of available assessments.\n\t *\n\t * @returns {module:parsedPaper/assess.Assessment[]} The list of all available assessments.\n\t */\n\tgetAssessments() {\n\t\treturn this._assessments;\n\t}\n\n\t/**\n\t * Assesses the given text by applying all the assessments to it\n\t * and aggregating the resulting scores.\n\t *\n\t * @param {Paper}                      paper The paper to assess. This contains metadata about the text.\n\t * @param {module:parsedPaper/structure.Node} node  The root node of the tree to check.\n\t *\n\t * @returns {Promise<{results: AssessmentResult[], score: number}>} The assessment results and the overall score.\n\t */\n\tasync assess( paper, node ) {\n\t\tconst applicableAssessments = await this.getApplicableAssessments( paper, node );\n\t\t/*\n\t\t  Apply every applicable assessment on the document.\n\t\t  Wait before they are done before aggregating the results\n\t\t  and returning the results and final score.\n\t\t */\n\t\tconst results = await Promise.all(\n\t\t\tapplicableAssessments.map( assessment => this.applyAssessment( assessment, paper, node ) )\n\t\t);\n\t\t// Filter out errored assessments.\n\t\tconst validResults = results.filter( result => result.getScore() !== -1 );\n\t\t// Compute overall score.\n\t\tconst score = this.scoreAggregator.aggregate( validResults );\n\n\t\treturn { results, score };\n\t}\n\n\t/**\n\t * Applies the given assessment to the paper-node combination.\n\t *\n\t * @param {module:parsedPaper/assess.Assessment} assessment The assessment to apply.\n\t * @param {Paper}                         paper      The paper to apply the assessment to.\n\t * @param {module:parsedPaper/structure.Node}    node       The root node of the tree to apply the assessment to.\n\t *\n\t * @returns {Promise<AssessmentResult>} The result of the assessment.\n\t */\n\tasync applyAssessment( assessment, paper, node ) {\n\t\treturn assessment.apply( paper, node ).catch(\n\t\t\t() => {\n\t\t\t\treturn new AssessmentResult( {\n\t\t\t\t\ttext: this.i18n.sprintf(\n\t\t\t\t\t\t/* Translators: %1$s expands to the name of the assessment. */\n\t\t\t\t\t\tthis.i18n.dgettext( \"js-text-analysis\", \"An error occurred in the '%1$s' assessment\" ),\n\t\t\t\t\t\tassessment.name,\n\t\t\t\t\t),\n\t\t\t\t\tscore: -1,\n\t\t\t\t} );\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Adds the assessment to the list of assessments to apply.\n\t *\n\t * @param {string}                        name       The name to register the assessment under.\n\t * @param {module:parsedPaper/assess.Assessment} assessment The assessment to add.\n\t *\n\t * @returns {void}\n\t */\n\tregisterAssessment( name, assessment ) {\n\t\tassessment.name = name;\n\t\tassessment.setResearcher( this.researcher );\n\t\tthis._assessments.push( assessment );\n\t}\n\n\t/**\n\t * Removes the assessment registered under the given name, if it exists.\n\t *\n\t * @param {string} name The name of the assessment to remove.\n\t *\n\t * @returns {module:parsedPaper/assess.Assessment|null} The deleted assessment, or null if no assessment has been deleted.\n\t */\n\tremoveAssessment( name ) {\n\t\tconst index = this._assessments.findIndex( assessment => assessment.name === name );\n\t\tif ( index > -1 ) {\n\t\t\tconst deleted = this._assessments.splice( index, 1 );\n\t\t\treturn deleted[ 0 ];\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the assessment registered under the given name.\n\t * Returns `null` if no assessment is registered under the given name.\n\t *\n\t * @param {string} name The name of the assessment to get.\n\t *\n\t * @returns {Assessment|null} The assessment.\n\t */\n\tgetAssessment( name ) {\n\t\tconst assessmentToReturn = this._assessments.find( assessment => assessment.name === name );\n\t\treturn assessmentToReturn ? assessmentToReturn : null;\n\t}\n\n\t/**\n\t * Sets the assessments that this assessor needs to apply.\n\t *\n\t * @param {module:parsedPaper/assess.Assessment[]} assessments The assessments to set.\n\t *\n\t * @returns {void}\n\t */\n\tsetAssessments( assessments ) {\n\t\tthis._assessments = assessments;\n\t}\n\n\t/**\n\t * Returns the list of applicable assessments.\n\t *\n\t * @param {Paper}                      paper The paper to check.\n\t * @param {module:parsedPaper/structure.Node} node  The tree to check.\n\t *\n\t * @returns {Promise<Array>} The list of applicable assessments.\n\t */\n\tasync getApplicableAssessments( paper, node ) {\n\t\t// List to store the applicable assessments in (empty for now).\n\t\tconst applicableAssessments = [];\n\n\t\t// Asynchronously add each assessment to the list if they are applicable.\n\t\tconst promises = this._assessments.map( assessment =>\n\t\t\tassessment.isApplicable( paper, node ).then(\n\t\t\t\tapplicable => {\n\t\t\t\t\tif ( applicable ) {\n\t\t\t\t\t\tapplicableAssessments.push( assessment );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\n\t\t// Wait before all the applicable assessments have been added before returning them.\n\t\treturn Promise.all( promises ).then( () => applicableAssessments );\n\t}\n}\n\nexport default TreeAssessor;\n"]}