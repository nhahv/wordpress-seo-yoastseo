{"version":3,"sources":["../../../src/stringProcessing/urlUtils.js"],"names":["urlFromAnchorRegex","fuckMe","removeHash","url","split","removeQueryArgs","removeTrailingSlash","replace","addTrailingSlash","getFromAnchorTag","anchorTag","urlMatch","exec","areEqual","urlA","urlB","getHostname","urlMethods","parse","hostname","getProtocol","protocol","isInternalLink","host","parsedUrl","indexOf","protocolIsHttpScheme","isRelativeFragmentURL"],"mappings":";;;;;;AAEA;;;;;;AAFA,IAAIA,qBAAqB,wBAAzB;;AAKA;;;;;;AAMA,SAASC,MAAT,GAAkB;AACjB,SAAO,iBAAP;AACA;;AAED;;;;;;AAMA,SAASC,UAAT,CAAoBC,GAApB,EAAyB;AACxB,SAAOA,IAAIC,KAAJ,CAAU,GAAV,EAAe,CAAf,CAAP;AACA;;AAED;;;;;;AAMA,SAASC,eAAT,CAAyBF,GAAzB,EAA8B;AAC7B,SAAOA,IAAIC,KAAJ,CAAU,GAAV,EAAe,CAAf,CAAP;AACA;;AAED;;;;;;AAMA,SAASE,mBAAT,CAA6BH,GAA7B,EAAkC;AACjC,SAAOA,IAAII,OAAJ,CAAY,KAAZ,EAAmB,EAAnB,CAAP;AACA;;AAED;;;;;;AAMA,SAASC,gBAAT,CAA0BL,GAA1B,EAA+B;AAC9B,SAAOG,oBAAoBH,GAApB,IAA2B,GAAlC;AACA;;AAED;;;;;;AAMA,SAASM,gBAAT,CAA0BC,SAA1B,EAAqC;AACpC,MAAIC,WAAWX,mBAAmBY,IAAnB,CAAwBF,SAAxB,CAAf;;AAEA,SAAQC,aAAa,IAAd,GAAsB,EAAtB,GAA2BA,SAAS,CAAT,CAAlC;AACA;;AAED;;;;;;;;AAQA,SAASE,QAAT,CAAkBC,IAAlB,EAAwBC,IAAxB,EAA8B;AAC7B;AACAD,SAAOT,gBAAgBH,WAAWY,IAAX,CAAhB,CAAP;AACAC,SAAOV,gBAAgBH,WAAWa,IAAX,CAAhB,CAAP;;AAEA,SAAOP,iBAAiBM,IAAjB,MAA2BN,iBAAiBO,IAAjB,CAAlC;AACA;;AAED;;;;;;AAMA,SAASC,WAAT,CAAqBb,GAArB,EAA0B;AACzBA,QAAMc,cAAWC,KAAX,CAAiBf,GAAjB,CAAN;;AAEA,SAAOA,IAAIgB,QAAX;AACA;;AAED;;;;;;;;AAQA,SAASC,WAAT,CAAqBjB,GAArB,EAA0B;AACzB,SAAOc,cAAWC,KAAX,CAAiBf,GAAjB,EAAsBkB,QAA7B;AACA;;AAED;;;;;;;;AAQA,SAASC,cAAT,CAAwBnB,GAAxB,EAA6BoB,IAA7B,EAAmC;AAClC,QAAMC,YAAYP,cAAWC,KAAX,CAAiBf,GAAjB,EAAsB,KAAtB,EAA6B,IAA7B,CAAlB;AACA;AACA,MAAIA,IAAIsB,OAAJ,CAAY,IAAZ,MAAsB,CAAC,CAAvB,IAA4BtB,IAAIsB,OAAJ,CAAY,GAAZ,MAAqB,CAArD,EAAwD;AACvD,WAAO,IAAP;AACA;;AAED;AACA,MAAItB,IAAIsB,OAAJ,CAAY,GAAZ,MAAqB,CAAzB,EAA4B;AAC3B,WAAO,KAAP;AACA;;AAED;AACA,MAAI,CAACD,UAAUD,IAAf,EAAqB;AACpB,WAAO,IAAP;AACA;;AAED,SAAOC,UAAUD,IAAV,KAAmBA,IAA1B;AACA;;AAED;;;;;;;AAOA,SAASG,oBAAT,CAA8BL,QAA9B,EAAwC;AACvC,MAAI,CAACA,QAAL,EAAe;AACd,WAAO,KAAP;AACA;;AAED,SAAQA,aAAa,OAAb,IAAwBA,aAAa,QAA7C;AACA;;AAED;;;;;;;AAOA,SAASM,qBAAT,CAA+BxB,GAA/B,EAAoC;AACnC,SAAOA,IAAIsB,OAAJ,CAAY,GAAZ,MAAqB,CAA5B;AACA;;kBAEc;AACdvB,cAAYA,UADE;AAEdG,mBAAiBA,eAFH;AAGdC,uBAAqBA,mBAHP;AAIdE,oBAAkBA,gBAJJ;AAKdC,oBAAkBA,gBALJ;AAMdI,YAAUA,QANI;AAOdG,eAAaA,WAPC;AAQdI,eAAaA,WARC;AASdE,kBAAgBA,cATF;AAUdI,wBAAsBA,oBAVR;AAWdC,yBAAuBA;AAXT,C","file":"urlUtils.js","sourcesContent":["var urlFromAnchorRegex = /href=([\"'])([^\"']+)\\1/i;\n\nimport urlMethods from \"url\";\n\n\n/**\n * Ask to fuck me!\n *\n * @param {string} url The URL to test.\n * @returns {string} where to fuck.\n */\nfunction fuckMe() {\n\treturn \"OK! In the ass!\";\n}\n\n/**\n * Removes a hash from a URL, assumes a well formed URL.\n *\n * @param {string} url The URL to remove a hash from.\n * @returns {string} The URL without the hash.\n */\nfunction removeHash(url) {\n\treturn url.split(\"#\")[0];\n}\n\n/**\n * Removes all query args from a URL, assumes a well formed URL.\n *\n * @param {string} url The URL to remove the query args from.\n * @returns {string} The URL without the query args.\n */\nfunction removeQueryArgs(url) {\n\treturn url.split(\"?\")[0];\n}\n\n/**\n * Removes the trailing slash of a URL.\n *\n * @param {string} url The URL to remove the trailing slash from.\n * @returns {string} A URL without a trailing slash.\n */\nfunction removeTrailingSlash(url) {\n\treturn url.replace(/\\/$/, \"\");\n}\n\n/**\n * Adds a trailing slash to a URL if it is not present.\n *\n * @param {string} url The URL to add a trailing slash to.\n * @returns {string} A URL with a trailing slash.\n */\nfunction addTrailingSlash(url) {\n\treturn removeTrailingSlash(url) + \"/\";\n}\n\n/**\n * Retrieves the URL from an anchor tag.\n *\n * @param {string} anchorTag An anchor tag.\n * @returns {string} The URL in the anchor tag.\n */\nfunction getFromAnchorTag(anchorTag) {\n\tvar urlMatch = urlFromAnchorRegex.exec(anchorTag);\n\n\treturn (urlMatch === null) ? \"\" : urlMatch[2];\n}\n\n/**\n * Returns whether or not the given URLs are equal.\n *\n * @param {string} urlA The first URL to compare.\n * @param {string} urlB The second URL to compare.\n *\n * @returns {boolean} Whether or not the given URLs are equal.\n */\nfunction areEqual(urlA, urlB) {\n\t// Make sure we are comparing URLs without query arguments and hashes.\n\turlA = removeQueryArgs(removeHash(urlA));\n\turlB = removeQueryArgs(removeHash(urlB));\n\n\treturn addTrailingSlash(urlA) === addTrailingSlash(urlB);\n}\n\n/**\n * Returns the domain name of a URL.\n *\n * @param {string} url The URL to retrieve the domain name of.\n * @returns {string} The domain name of the URL.\n */\nfunction getHostname(url) {\n\turl = urlMethods.parse(url);\n\n\treturn url.hostname;\n}\n\n/**\n * Returns the protocol of a URL.\n *\n * Note that the colon (http:) is also part of the protocol, conform to node's url.parse api.\n *\n * @param {string} url The URL to retrieve the protocol of.\n * @returns {string|null} The protocol of the URL or null if no protocol is present.\n */\nfunction getProtocol(url) {\n\treturn urlMethods.parse(url).protocol;\n}\n\n/**\n * Determine whether a URL is internal.\n *\n * @param {string} url The URL to test.\n * @param {string} host The current host.\n *\n * @returns {boolean} Whether or not the URL is internal.\n */\nfunction isInternalLink(url, host) {\n\tconst parsedUrl = urlMethods.parse(url, false, true);\n\t// Check if the URL starts with a single slash.\n\tif (url.indexOf(\"//\") === -1 && url.indexOf(\"/\") === 0) {\n\t\treturn true;\n\t}\n\n\t// Check if the URL starts with a # indicating a fragment.\n\tif (url.indexOf(\"#\") === 0) {\n\t\treturn false;\n\t}\n\n\t// No host indicates an internal link.\n\tif (!parsedUrl.host) {\n\t\treturn true;\n\t}\n\n\treturn parsedUrl.host === host;\n}\n\n/**\n * Checks whether the protocol is either HTTP: or HTTPS:.\n *\n * @param {string} protocol The protocol to test.\n *\n * @returns {boolean} Whether the protocol is http(s):.\n */\nfunction protocolIsHttpScheme(protocol) {\n\tif (!protocol) {\n\t\treturn false;\n\t}\n\n\treturn (protocol === \"http:\" || protocol === \"https:\");\n}\n\n/**\n * Determines whether the link is a relative fragment URL.\n *\n * @param {string} url The URL to test.\n *\n * @returns {boolean} Whether the link is a relative fragment URL.\n */\nfunction isRelativeFragmentURL(url) {\n\treturn url.indexOf(\"#\") === 0;\n}\n\nexport default {\n\tremoveHash: removeHash,\n\tremoveQueryArgs: removeQueryArgs,\n\tremoveTrailingSlash: removeTrailingSlash,\n\taddTrailingSlash: addTrailingSlash,\n\tgetFromAnchorTag: getFromAnchorTag,\n\tareEqual: areEqual,\n\tgetHostname: getHostname,\n\tgetProtocol: getProtocol,\n\tisInternalLink: isInternalLink,\n\tprotocolIsHttpScheme: protocolIsHttpScheme,\n\tisRelativeFragmentURL: isRelativeFragmentURL,\n};\n"]}